from __future__ import annotations
import argparse
from pathlib import Path

from .io_utils import RUNS_ROOT, ensure_dir, write_json, write_yaml, write_text
from .parser import prompt_to_scenario
from .utils import timestamp_slug, slugify, git_hash_fallback
from . import __version__

# Step-2 pieces (optional if you added them earlier)
try:
    from .rollout import run_batch
    from .metrics import aggregate, write_summary
    from .reporter import write_report
    from .coverage import build_coverage   # <-- NEW: real coverage counters
except Exception:
    run_batch = None
    aggregate = None
    write_summary = None
    write_report = None
    build_coverage = None

# Step-3 single-run sim
from .sim_one import run_one

def _make_run_dir(prompt: str, name: str | None) -> Path:
    stamp = timestamp_slug()
    label = slugify(name or prompt)
    run_dir = RUNS_ROOT / f"{stamp}_{label}"
    ensure_dir(run_dir)
    return run_dir

def _write_core_files(run_dir: Path, prompt: str, n_runs: int, seed_base: int, scn: dict) -> dict:
    seeds = {"base_seed": seed_base, "seeds": [seed_base + i for i in range(n_runs)]}
    manifest = {
        "prompt": prompt,
        "n_runs": n_runs,
        "seed_base": seed_base,
        "version": __version__,
        "git": git_hash_fallback(),
    }
    write_yaml(run_dir / "scenario.yaml", scn)
    write_json(run_dir / "seeds.json", seeds)
    write_json(run_dir / "manifest.json", manifest)
    return {"seeds": seeds, "manifest": manifest}

def cmd_simulate(args: argparse.Namespace) -> int:
    prompt: str = args.prompt
    n_runs: int = int(args.runs)
    seed_base: int = int(args.seed)
    scn = prompt_to_scenario(prompt, n_runs=n_runs)
    run_dir = _make_run_dir(prompt, args.name)
    _write_core_files(run_dir, prompt, n_runs, seed_base, scn)
    write_text(
        run_dir / "RUN_README.md",
        """# EdgeSim Run (V0 Step 1)

This folder was generated by `edgesim simulate`.

**Includes:**
- `scenario.yaml`
- `seeds.json`
- `manifest.json`
"""
    )
    print(f"\n[EdgeSim] Created run @ {run_dir}\n- scenario.yaml\n- seeds.json\n- manifest.json\n")
    return 0

def cmd_run_batch(args: argparse.Namespace) -> int:
    if run_batch is None:
        raise SystemExit("Batch runner modules not available. Add rollout/metrics/reporter or skip this command.")
    prompt: str = args.prompt
    n_runs: int = int(args.runs)
    seed_base: int = int(args.seed)
    profile: str = args.profile
    scn = prompt_to_scenario(prompt, n_runs=n_runs)
    run_dir = _make_run_dir(prompt, args.name)
    files = _write_core_files(run_dir, prompt, n_runs, seed_base, scn)
    seeds = files["seeds"]["seeds"]

    # Execute batch
    run_batch(prompt, scn, seeds, run_dir, profile=profile)

    # Build coverage from per-run CSVs (fallback to empty dict if module missing)
    coverage = {}
    if build_coverage is not None:
        coverage = build_coverage(run_dir / "per_run")

    # Aggregate summary + write artifacts
    summary = aggregate(run_dir / "per_run")
    write_summary(run_dir, summary)
    write_json(run_dir / "coverage.json", coverage)
    write_report(run_dir, prompt, files["manifest"], coverage, summary)

    print(f"\n[EdgeSim] Batch done @ {run_dir}\n- per_run/*.csv\n- summary.json\n- coverage.json\n- report.md\n")
    return 0

def cmd_run_one(args: argparse.Namespace) -> int:
    prompt: str = args.prompt
    gui: bool = bool(args.gui)
    realtime: bool = bool(args.realtime)
    scn = prompt_to_scenario(prompt, n_runs=1)
    run_dir = _make_run_dir(prompt, args.name)
    _write_core_files(run_dir, prompt, 1, args.seed, scn)
    out = run_one(prompt, scn, run_dir, dt=0.05, realtime=realtime, gui=gui)
    print(f"\n[EdgeSim] Single rollout @ {run_dir}\n- success={out['success']} time={out['time']:.2f}s steps={out['steps']}\n- run_one.csv\n")
    return 0

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="edgesim", description="EdgeSim V0 CLI")
    sub = p.add_subparsers(dest="command", required=True)

    sp = sub.add_parser("simulate", help="Parse prompt → Scenario Graph & create run folder")
    sp.add_argument("prompt", type=str)
    sp.add_argument("--runs", type=int, default=100)
    sp.add_argument("--seed", type=int, default=42)
    sp.add_argument("--name", type=str, default=None)
    sp.set_defaults(func=cmd_simulate)

    sb = sub.add_parser("run-batch", help="Seeded batch → CSVs + summary + report")
    sb.add_argument("prompt", type=str)
    sb.add_argument("--runs", type=int, default=100)
    sb.add_argument("--seed", type=int, default=42)
    sb.add_argument("--name", type=str, default=None)
    sb.add_argument("--profile", type=str, default="minimal", choices=["minimal","robot","full"])
    sb.set_defaults(func=cmd_run_batch)

    so = sub.add_parser("run-one", help="Run a single PyBullet rollout (V0)")
    so.add_argument("prompt", type=str)
    so.add_argument("--seed", type=int, default=42)
    so.add_argument("--name", type=str, default=None)
    so.add_argument("--gui", action="store_true", help="Open PyBullet GUI")
    so.add_argument("--realtime", action="store_true", help="Sleep to realtime")
    so.set_defaults(func=cmd_run_one)

    return p

def main() -> int:
    parser = build_parser()
    args = parser.parse_args()
    return args.func(args)

if __name__ == "__main__":
    exit(main())
